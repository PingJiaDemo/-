<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

</head>
<body>
<div id="container"></div>

<script src="../CiteFire/three.js"></script>
<script>

    var camera,scene,renderer;
    var isUserInteracting = false,//用户是否正在操作
        onMouseDownMouseX = 0, onMouseDownMouseY = 0,//鼠标点击的x和Y坐标
        lon = 0, onMouseDownLon = 0,//经度
        lat = 0, onMouseDownLat = 0,//纬度
        phi = 0, theta = 0;//计算相机位置的重要参数
    init();
    animate();
    function init() {
        var container,mesh;

        container=document.getElementById('container');

        camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,1,1100);
        camera.target=new THREE.Vector3(0,0,0);

        scene=new THREE.Scene();

        var  geometry=new THREE.SphereBufferGeometry(500,60,40);
         geometry.scale(-1,1,1);

         var meterial=new THREE.MeshBasicMaterial({
             map:new THREE.TextureLoader().load('textures/2294472375_24a3b8ef46_o.jpg')
         });
         mesh=new THREE.Mesh(geometry,meterial);

         scene.add(mesh);

         renderer=new THREE.WebGLRenderer();
         renderer.setPixelRatio(window.devicePixelRatio);
         renderer.setSize(window.innerWidth,window.innerHeight);
         container.appendChild(renderer.domElement);


         //鼠标、手机touch的各个事件
         document.addEventListener('mousedown',onPointerStart,false);
        document.addEventListener( 'mousemove', onPointerMove, false );
        document.addEventListener( 'mouseup', onPointerUp, false );
        document.addEventListener( 'wheel', onDocumentMouseWheel, false );

        document.addEventListener( 'touchstart', onPointerStart, false );
        document.addEventListener( 'touchmove', onPointerMove, false );
        document.addEventListener( 'touchend', onPointerUp, false );

        document.addEventListener( 'dragover', function ( event ) {

            event.preventDefault();
            event.dataTransfer.dropEffect = 'copy';

        }, false );

        document.addEventListener( 'dragenter', function () {

            document.body.style.opacity = 0.5;

        }, false );

        document.addEventListener( 'dragleave', function () {

            document.body.style.opacity = 1;

        }, false );

        document.addEventListener( 'drop', function ( event ) {

            event.preventDefault();

            var reader = new FileReader();
            reader.addEventListener( 'load', function ( event ) {

                material.map.image.src = event.target.result;
                material.map.needsUpdate = true;

            }, false );
            reader.readAsDataURL( event.dataTransfer.files[ 0 ] );

            document.body.style.opacity = 1;

        }, false );


        window.addEventListener( 'resize', onWindowResize, false );
    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function onPointerStart(event) {
        isUserInteracting = true;

        var clientX = event.clientX || event.touches[ 0 ].clientX;
        var clientY = event.clientY || event.touches[ 0 ].clientY;

        onMouseDownMouseX = clientX;
        onMouseDownMouseY = clientY;

        onMouseDownLon = lon;
        onMouseDownLat = lat;
    }
    function onPointerMove( event ) {

        if ( isUserInteracting === true ) {

            var clientX = event.clientX || event.touches[ 0 ].clientX;
            var clientY = event.clientY || event.touches[ 0 ].clientY;

            lon = ( onMouseDownMouseX - clientX ) * 0.1 + onMouseDownLon;
            lat = ( clientY - onMouseDownMouseY ) * 0.1 + onMouseDownLat;

        }

    }
    function onPointerUp() {

        isUserInteracting = false;

    }
    function onDocumentMouseWheel( event ) {

        var fov = camera.fov + event.deltaY * 0.05;

        camera.fov = THREE.Math.clamp( fov, 10, 75 );

        camera.updateProjectionMatrix();

    }
    function animate() {

        requestAnimationFrame( animate );
        update();

    }

    function update() {
        if(isUserInteracting==false){
            //自动旋转
            lon+=0.1;

        }
        lat=Math.max(-85,Math.min(85,lat));
        phi = THREE.Math.degToRad( 90 - lat );
        theta = THREE.Math.degToRad( lon );

        camera.target.x = 500 * Math.sin( phi ) * Math.cos( theta );
        camera.target.y = 500 * Math.cos( phi );
        camera.target.z = 500 * Math.sin( phi ) * Math.sin( theta );

        camera.lookAt( camera.target );

        renderer.render( scene, camera );
    }
</script>
</body>
</html>